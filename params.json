{"name":"graph-json","tagline":"A JSON-format backed graph with preliminary identification algorithms","body":"# graph-json [![Build Status](https://travis-ci.org/mananshah99/graph-json.svg?branch=master)](https://travis-ci.org/mananshah99/graph-json) [![NPM version](https://badge.fury.io/js/graph-json.svg)](http://badge.fury.io/js/graph-json)\r\n\r\n[![NPM](https://nodei.co/npm/graph-json.png?downloads=true)](https://nodei.co/npm/graph-json/)\r\n\r\nA JSON-format backed graph with basic identification algorithms. \r\n\r\n## JSON Scheme: \r\n```json\r\n{\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"nodes\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n                \"type\": \"object\",\r\n                \"properties\": {\r\n                    \"name\": {\r\n                        \"type\": \"string\",\r\n                        \"required\": true\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \"edges\": {\r\n            \"type\": \"array\",\r\n            \"items\": {\r\n                \"type\": \"object\",\r\n                \"properties\": {\r\n                    \"name\": {\r\n                        \"type\": \"string\",\r\n                        \"required\": true\r\n                    },\r\n                    \"from\": {\r\n                        \"type\": \"string\",\r\n                        \"required\": true\r\n                    },\r\n                    \"to\": {\r\n                        \"type\": \"string\",\r\n                        \"required\": true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Documentation\r\n\r\n### function ValidationError(message, err) \r\n\r\nSpecific error to the `graph-json` module that is thrown whenever a portion of the graph schema is unable to validated properly. \r\n\r\nPotential times this error would be thrown are if: a) hanging edges exist in the graph, b) the JSON file provided does not match the default specification, c) no JSON file is provided, d) duplicate nodes are provided in the JSON file, or e) duplicate edges are provided in the JSON file.\r\n\r\nExample:\r\n```js\r\nvar scheme = require('./scheme.json');\r\n\r\n//struct is the graph structure that's passed in\r\nvar test = validator.validate(struct, scheme);\r\nif (test.errors.length > 0) {\r\n    return new ValidationError('Validation of Graph Failed: ', test.errors);\r\n}\r\n```\r\n\r\n### function Graph([struct])\r\n\r\nCreates a graph based on the structure defined (a `.json` object matching the specification), or creates a graph with no edges and nodes if `struct` is not specified. \r\n\r\nAn example struct would look like the following (used in the remainder of the documentation) \r\n```json\r\n{\r\n    \"nodes\": [\r\n        {\r\n            \"name\": \"A\"\r\n        },\r\n        {\r\n            \"name\": \"B\"\r\n        },\r\n        {\r\n            \"name\": \"C\",\r\n            \"data\": \"__DATA__\"\r\n        },\r\n        { \r\n            \"name\": \"T\"\r\n        }\r\n    ],\r\n    \"edges\": [\r\n        {\r\n            \"name\": \"AB\",\r\n            \"from\": \"A\",\r\n            \"to\": \"B\",\r\n            \"data\" : \"__DATA__\"\r\n        },\r\n        {\r\n            \"name\": \"BC\",\r\n            \"from\": \"B\",\r\n            \"to\": \"C\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nIn order to create a graph, you'll want to parse your JSON object and pass it as a parameter. For example, \r\n```js\r\n//g is the JSON parsed object of graph.json located in the executing directory\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\n\r\n//t_graph is the graph created from graph.json\r\nvar t_graph = new Graph(g);\r\n```\r\nOr, you can create a graph without specifying a JSON file: \r\n```js\r\nvar t_graph = new Graph();\r\n```\r\nThe graph above contains no nodes and no edges. \r\n\r\n### Graph.prototype.edgesIn = function (node) \r\n\r\nReturns the number of edges entering a given node. \r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nvar x = t_graph.edgesIn('B');\r\nconsole.log(x[0].from); // #==> for the test graph, should print 'A'\r\n```\r\n\r\n### Graph.prototype.edgesOut = function (node) \r\n\r\nReturns the number of edges exiting a given node. \r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nvar x = t_graph.edgesOut('A');\r\nconsole.log(x[0].to) // #==> for the test graph, should print 'B'\r\n```\r\n\r\n### Graph.prototype.getNode = function (id) \r\n\r\nReturns a node contained in the graph with the given name (`id`).\r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nvar node = t_graph.getNode('C'); // #==> assigns the variable node to the node of the graph with name 'C'\r\n```\r\n\r\n### Graph.prototype.numNodes = function ()\r\n\r\nReturns the number of nodes contained in the graph.\r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nconsole.log(t_graph.numNodes()); // #==> prints '3' for the test graph\r\n```\r\n\r\n### Graph.prorotype.getEdge = function (id) \r\n\r\nReturns an edge contained in the graph with the given name (`id`).\r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nvar edge = t_graph.getEdge('BC'); // #==> assigns the variable edge to the edge of the graph with name 'BC'\r\n```\r\n\r\n### Graph.prototype.numEdges = function () \r\n\r\nReturns the number of edges contained in the graph.\r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nconsole.log(t_graph.numEdges()) // #==> prints '2' for the test graph\r\n```\r\n\r\n### Graph.prototype.edges = function () \r\n\r\nReturns the edges array internally stored in `graph-json`. \r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nvar edge_array = t_graph.edges();\r\n```\r\n\r\n### Graph.prototype.isTerminal = function (node) \r\n\r\nReturns `true` if the specified node is ternminal (has no children), and false otherwise. \r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nconsole.log(t_graph.isTerminal('T')); // #==> prints 'true' for the test graph\r\n```\r\n\r\n### Graph.prototype.dfs = function (to_find, node, graph)\r\n\r\nPerforms a depth-first-search on the given graph, searching for `to_find` starting from `node`. \r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nconsole.log((t_graph.dfs('B', 'A', t_graph)); // #==> prints 'B' for the test graph (search successful) \r\nconsole.log((t_graph.dfs('dne', 'A', t_graph)); // #==> prints 'null' for the test graph (search failed) \r\n```\r\n\r\n### function hangingEdges(graph, edges) \r\n\r\nReturns an array of the \"hanging edges\" - edges that either have no `from` or `to` node defined - in the current graph schema. \r\n\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nvar x = hangingEdges(t_graph, t_graph.edges);\r\nif (x.length !== 0) {\r\n    return new ValidationError('Hanging Edges Found: ', x); // # ==> uh-oh! We have hanging edges in the graph.\r\n}\r\n// #==> seeing as the test graph is properly defined, no validation error will be thrown.\r\n```\r\n\r\n### Graph.prototype.addNode = function (name, [dt]) \r\n\r\nAdds a node to the graph with an optional parameter containing data. \r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\ng.addNode('A'); // adds node 'A' to the graph\r\ng.addNode('B', 'xyz'); // adds node 'B' to the graph, with data xyz\r\n```\r\n\r\n### Graph.prototype.addEdge = function (name, from, to, [dt])\r\n\r\nAdds an edge to the graph with an optional parameter containing data.\r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\ng.addEdge('A->B', 'A', 'B'); // adds edge 'A->B' to the graph from node A to node B\r\ng.addEdge('A->C', 'A', 'C', '10'); // adds edge 'A->C' to the graph from node A to node C with data 10\r\n```\r\n\r\n### Graph.prototype.add = function([nodes...]) \r\n\r\nAdds any number of nodes to a graph, automatically creating the nodes if they do not exist and creating edges between each adjacent node.\r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\n// the following creates nodes 'a', 'b', 'c', and 'd' if they do not exist,\r\n// and then creates the edges a->b, b->c, and c->d\r\nt_graph.add('a', 'b', 'c', 'd'); \r\n```\r\n\r\n### Graph.prototype.tSort = function ()\r\n\r\nTopologically sorts the graph and returns the resulting node array.\r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nconsole.log(t_graph.tSort()); //prints a comma-delimited topologically sorted node order of t_graph\r\n```\r\n\r\n### Graph.prototype.isAcyclic = function ()\r\n\r\nReturns `true` if the graph is acyclic, `false` otherwise. Uses a topological sort under the hood. \r\n\r\nExample:\r\n```js\r\nvar g = JSON.parse(fs.readFileSync('./graph.json'));\r\nvar t_graph = new Graph(g);\r\n\r\nif(t_graph.isAcyclic()) {\r\n    //do something\r\n}\r\nelse {\r\n    //do something else\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}